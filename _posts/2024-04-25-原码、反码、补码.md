---
title: "原码、反码、补码"
tags: [计算机基础,数字编码,原码,反码,补码]
---

为什么有这么多码？

---

## 基本概念
1. **原码**：我们将数字的二进制表示的最高位视为符号位，其中`0`表示正数，`1`表示负数，其余位表示数字的值。
2. **反码**：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。
3. **补码**：正数的补码与其原码相同，负数的补码是在其反码的基础上加1。

## 为什么要使用反码、补码
负数的原码不能直接用于运算（直接做加法运算），进而引入了反码，为了避免正负0的歧义，进而引入了补码

### 反码

`1`：`0000 0001`

`-2`：`1000 0010`

计算 1 + (-2)

```
原码直接计算
1 + (-2)
-> 0000 0001 + 1000 0010
 = 1000 0011
 = -3
```

```
反码计算
1 + (-2)
 = 0000 0001(原) + 1000 0010(原)
-> 0000 0001(反) + 1111 1101(反)
 = 1111 1110(反)
-> 1000 0001(原)
 = -1
```
### 补码
使用原码/反码存储时，`0000 0000`（反码`0000 0000`）和`1000 0000`（反码`1111 1111`）都表示0，一个是+0，一个是-0，这意味着数字零对应两个不同的二进制编码，这可能会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。
```
补码表示-0
1000 0000(原) -> 1111 1111(反) -> 1 0000 0000(补，含高位) --两字节存储，高位舍弃--> 0000 0000(补)
```

```
补码计算
1 + (-2)
 = 0000 0001(原) + 1000 0010(原)
-> 0000 0001(反) + 1111 1101(反)
-> 0000 0001(补) + 1111 1110(补)
 = 1111 1111(补)
-> 1000 0001(原)
 = -1
```
这时+0、-0对应的补码都是`0000 0000`，不存在0歧义的问题了，但又有了新的问题，原码跟补码的数量是一样的，两个原码对应同一个补码时，意味着一定有一个补码没有被原码对应（反码的`1111 1111`~`1000 0000` 都是有对应原码的，意味着补码`0000 0000`、`1111 1111`~`1000 0001`都是有对应原码的，可以看出，补码`1000 0000`是没有对应原码的）
